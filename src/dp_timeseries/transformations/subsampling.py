import numpy as np
from gluonts.dataset.common import DataEntry
from gluonts.transform._base import SimpleTransformation
from abc import abstractmethod
from numpy.typing import NDArray


class SubsampleTransformation(SimpleTransformation):
    """Transform that applies subsampling in time domain.

    Indices that are not sampled are set to np.nan.

    Attributes:
        target_field (None | str): Field with target values (array) of time series.
        observed_values_field (None | str): Field generated by AddObservedValuesIndicator.
        is_pad_field (None | str): Field generated by other transforms that pad
    """

    def __init__(self,
                 target_field: str,
                 observed_values_field: None | str = None,
                 is_pad_field: None | str = None) -> None:

        self.target_field = target_field
        self.observed_values_field = observed_values_field
        self.is_pad_field = is_pad_field

    def transform(self, data: DataEntry) -> DataEntry:
        targets = data[self.target_field]

        if (not isinstance(targets, np.ndarray)) or targets.dtype.kind != 'f':
            raise ValueError(f'data[{self.target_field}] must be float array')
        if not targets.ndim == 1:
            raise NotImplementedError(
                'Subsampling only supports 1 dimension, but '
                f'{data[self.target_field].ndim=}.')

        if self.observed_values_field is not None:
            observed = data[self.observed_values_field]
            if observed.dtype.kind != 'f' or np.any(observed != 1):
                raise NotImplementedError

        if self.is_pad_field is not None:
            is_pad = data[self.is_pad_field]
            if is_pad.dtype.kind != 'f' or np.any(is_pad != 0):
                raise NotImplementedError

        keep_mask = self.sample_keep_mask(len(targets))

        targets[~keep_mask] = np.nan
        assert np.all(np.isnan(data[self.target_field])
                      == np.logical_not(keep_mask))

        return data

    @abstractmethod
    def sample_keep_mask(self, sequence_length: int) -> NDArray[np.bool_]:
        raise NotImplementedError


class SubsamplePoisson(SubsampleTransformation):
    def __init__(self,
                 target_field: str,
                 subsampling_rate: float,
                 observed_values_field: None | str = None,
                 is_pad_field: None | str = None) -> None:

        super().__init__(target_field, observed_values_field, is_pad_field)

        if not (0 <= subsampling_rate <= 1):
            raise ValueError(f'Subsampling rate must be in [0,1], but {subsampling_rate=}')

        self.subsampling_rate = subsampling_rate

    def sample_keep_mask(self, sequence_length: int) -> NDArray[np.bool_]:
        return np.random.binomial(
                    1, self.subsampling_rate, sequence_length).astype(bool)


class SubsampleWithoutReplacement(SubsampleTransformation):
    def __init__(self,
                 target_field: str,
                 context_length: int,
                 num_samples: int,
                 observed_values_field: None | str = None,
                 is_pad_field: None | str = None) -> None:

        super().__init__(target_field, observed_values_field, is_pad_field)
        if num_samples > context_length:
            raise ValueError('num_samples must be l.e.q. context_length.')

        self.num_samples = num_samples
        self.context_length = context_length

    def sample_keep_mask(self, sequence_length: int) -> NDArray[np.bool_]:
        keep_idx = np.random.choice(
                sequence_length, self.num_samples, replace=False)

        keep_mask = np.zeros(sequence_length, dtype=bool)
        keep_mask[keep_idx] = True

        return keep_mask

    def transform(self, data: DataEntry) -> DataEntry:
        targets = data[self.target_field]

        if len(targets) != self.context_length:
            raise ValueError

        return super().transform(data)
